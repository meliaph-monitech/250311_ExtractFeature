# -*- coding: utf-8 -*-
"""WORK_250311_ExtractFeatureUI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZMflS1GhPm-ICX9IJK5pJJPbwcBDjwHt
"""

import streamlit as st
import pandas as pd
import zipfile
import io
import os
import numpy as np
from scipy.stats import skew, kurtosis
from scipy.fftpack import fft, fftfreq
from scipy.signal import find_peaks

# Function to extract advanced features
def extract_advanced_features(signal, fs=1):
    features = {}
    n = len(signal)
    if n == 0:
        return {}

    # Statistical & time-domain features
    features['mean'] = np.mean(signal)
    features['std'] = np.std(signal)
    features['var'] = np.var(signal)
    features['min'] = np.min(signal)
    features['max'] = np.max(signal)
    features['median'] = np.median(signal)
    features['skewness'] = skew(signal)
    features['kurtosis'] = kurtosis(signal)
    features['peak_to_peak'] = np.ptp(signal)
    features['energy'] = np.sum(signal**2)
    features['rms'] = np.sqrt(np.mean(signal**2))

    # Frequency-domain features
    signal_fft = fft(signal)
    psd = np.abs(signal_fft)**2
    freqs = fftfreq(n, 1/fs)
    positive_freqs = freqs[:n // 2]
    positive_psd = psd[:n // 2]

    if len(positive_psd) > 0:
        features['dominant_frequency'] = positive_freqs[np.argmax(positive_psd)]
    else:
        features['dominant_frequency'] = 0

    return features

# Upload ZIP file
st.title("NVH Signal Processing & Feature Extraction")
uploaded_file = st.file_uploader("Upload ZIP File containing CSVs", type=["zip"])

if uploaded_file is not None:
    # Extract ZIP file
    with zipfile.ZipFile(uploaded_file, "r") as z:
        z.extractall("temp_data")
        csv_files = [f for f in os.listdir("temp_data") if f.endswith(".csv")]

    st.success(f"Extracted {len(csv_files)} CSV files.")

    # Load CSVs
    all_data = {}
    for file in csv_files:
        df = pd.read_csv(os.path.join("temp_data", file))
        all_data[file] = df

    # Select filter column & threshold
    sample_df = next(iter(all_data.values()))
    columns = sample_df.columns.tolist()
    filter_column = st.selectbox("Select Filter Column", columns)
    filter_threshold = st.number_input("Enter Filter Threshold", value=0.0)

    if st.button("Segment Beads"):
        st.write("Segmenting beads...")
        segmented_data = []

        for file, df in all_data.items():
            signal = df[filter_column].to_numpy()
            start_indices, end_indices = [], []
            i = 0
            while i < len(signal):
                if signal[i] > filter_threshold:
                    start = i
                    while i < len(signal) and signal[i] > filter_threshold:
                        i += 1
                    end = i - 1
                    start_indices.append(start)
                    end_indices.append(end)
                else:
                    i += 1

            for start, end in zip(start_indices, end_indices):
                bead_segment = df.iloc[start:end+1]
                segmented_data.append({
                    "file": file,
                    "start_index": start,
                    "end_index": end,
                    "data": bead_segment
                })

        st.success(f"Segmentation completed! Found {len(segmented_data)} bead segments.")

    # Feature selection
    feature_options = list(extract_advanced_features(np.random.rand(10)).keys())
    selected_features = st.multiselect("Select Features to Extract", ["All"] + feature_options, default=["All"])

    if "All" in selected_features:
        selected_features = feature_options

    if st.button("Extract Features"):
        st.write("Extracting features...")
        progress_bar = st.progress(0)
        features_list = []

        for i, segment in enumerate(segmented_data):
            signal = segment['data'].iloc[:, 0].values
            file_name = segment['file']

            feature_dict = extract_advanced_features(signal)
            selected_feature_dict = {k: feature_dict[k] for k in selected_features if k in feature_dict}
            selected_feature_dict.update({
                "file": file_name,
                "start_index": segment["start_index"],
                "end_index": segment["end_index"]
            })
            features_list.append(selected_feature_dict)

            progress_bar.progress((i+1)/len(segmented_data))

        features_df = pd.DataFrame(features_list)
        features_df['file_name'] = features_df['file'].str.split('/').str[-1]
        features_df = features_df.rename(columns={'file': 'file_dir'})
        st.success("Feature extraction complete!")

        # Provide download link
        output = io.BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            features_df.to_excel(writer, index=False)
        output.seek(0)
        st.download_button(label="Download Results", data=output, file_name="extracted_features.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")